import { EnhancedAgenticPlanner } from '../planning/enhanced-agentic-planner';
import { EnhancedContextManager } from '../context/enhanced-context-manager';
import { PerformanceOptimizer } from '../analytics/performance-optimizer';
import { ExaSearchTool } from '../../mcp-tools/exa-search-tool';
import { HuggingFaceTool } from '../../mcp-tools/huggingface-tool';
import { LocalModelClient } from '../local-model-client';
import { VoiceArchetypeSystem } from '../../voices/voice-archetype-system';
import { MCPServerManager } from '../../mcp-servers/mcp-server-manager';
import { logger } from '../logger';
import { AppConfig } from '../../config/config-manager';

export interface EnhancedSystemConfig {
  planning: {
    enabled: boolean;
    maxConcurrentTasks: number;
    autoRecovery: boolean;
    contextAware: boolean;
  };
  context: {
    enabled: boolean;
    maxSize: number;
    persistencePath: string;
    crossSessionRetention: boolean;
  };
  analytics: {
    enabled: boolean;
    learningEnabled: boolean;
    persistencePath: string;
    optimizationThreshold: number;
  };
  tools: {
    exaSearch: {
      enabled: boolean;
      apiKey?: string;
    };
    huggingFace: {
      enabled: boolean;
      apiKey?: string;
    };
  };
}

export interface SystemStatus {
  planning: {
    isReady: boolean;
    activePlans: number;
    completedTasks: number;
    failedTasks: number;
  };
  context: {
    isReady: boolean;
    totalItems: number;
    memoryUsage: number;
    sessionId: string;
  };
  analytics: {
    isReady: boolean;
    totalMetrics: number;
    learnedPatterns: number;
    suggestions: number;
  };
  tools: {
    available: string[];
    connected: string[];
    failed: string[];
  };
}

/**
 * Enhanced System Integration Manager
 * 
 * Orchestrates all enhanced components of the CodeCrucible Synth system:
 * - Enhanced Agentic Planning
 * - Context Management
 * - Performance Analytics
 * - Additional MCP Tools
 * 
 * Provides a unified interface for the enhanced agentic capabilities.
 */
export class EnhancedSystemIntegration {
  private config: EnhancedSystemConfig;
  private appConfig: AppConfig;
  
  // Core components
  private modelClient: LocalModelClient;
  private voiceSystem: VoiceArchetypeSystem;
  private mcpManager: MCPServerManager;
  
  // Enhanced components
  private planner?: EnhancedAgenticPlanner;
  private contextManager?: EnhancedContextManager;
  private performanceOptimizer?: PerformanceOptimizer;
  private exaSearchTool?: ExaSearchTool;
  private huggingFaceTool?: HuggingFaceTool;
  
  private isInitialized = false;
  private initializationPromise?: Promise<void>;

  constructor(
    modelClient: LocalModelClient,
    voiceSystem: VoiceArchetypeSystem,
    mcpManager: MCPServerManager,
    appConfig: AppConfig
  ) {
    this.modelClient = modelClient;
    this.voiceSystem = voiceSystem;
    this.mcpManager = mcpManager;
    this.appConfig = appConfig;
    
    // Load configuration
    this.config = this.loadEnhancedConfig(appConfig);
  }

  /**
   * Initialize all enhanced components
   */
  async initialize(): Promise<void> {
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    
    this.initializationPromise = this.performInitialization();
    return this.initializationPromise;
  }

  private async performInitialization(): Promise<void> {
    logger.info('üöÄ Initializing Enhanced CodeCrucible System...');
    
    try {
      // Initialize performance optimizer first (for metrics collection)
      if (this.config.analytics.enabled) {
        await this.initializePerformanceOptimizer();
      }
      
      // Initialize context manager
      if (this.config.context.enabled) {
        await this.initializeContextManager();
      }
      
      // Initialize enhanced planner
      if (this.config.planning.enabled) {
        await this.initializeEnhancedPlanner();
      }
      
      // Initialize additional MCP tools
      await this.initializeAdditionalTools();
      
      this.isInitialized = true;
      logger.info('‚úÖ Enhanced system initialization complete');
      
      // Log system status
      const status = await this.getSystemStatus();
      logger.info('System Status:', JSON.stringify(status, null, 2));
      
    } catch (error) {
      logger.error('‚ùå Enhanced system initialization failed:', error);
      throw error;
    }
  }

  /**
   * Create and execute an enhanced plan with full system integration
   */
  async executeEnhancedPlan(
    objective: string,
    options: {
      priority?: 'low' | 'medium' | 'high';
      useContext?: boolean;
      trackPerformance?: boolean;
      onProgress?: (taskId: string, status: string, progress: number) => void;
    } = {}
  ): Promise<{
    success: boolean;
    results: any[];
    analytics: any;
    suggestions: any[];
  }> {
    if (!this.isInitialized) {
      await this.initialize();
    }
    
    logger.info(`üéØ Executing enhanced plan: ${objective}`);
    
    const startTime = Date.now();
    
    try {
      // Add context for this objective
      if (this.contextManager && options.useContext !== false) {
        await this.contextManager.addContext(
          `objective_${Date.now()}`,
          { objective, timestamp: Date.now(), priority: options.priority },
          { type: 'execution', tags: ['objective', 'planning'], priority: options.priority || 'medium' }
        );
      }
      
      // Create enhanced plan
      const plan = await this.planner!.createPlan(objective);
      
      // Get relevant context
      let contextForTasks = {};
      if (this.contextManager) {
        // For now, we'll create a dummy task to get context
        const dummyTask = {
          id: 'context_lookup',
          description: objective,
          tool: 'context',
          args: {},
          dependencies: [],
          status: 'pending' as const,
          priority: options.priority || 'medium' as const,
          retryCount: 0,
          maxRetries: 3
        };
        
        contextForTasks = await this.contextManager.getContextForTask(dummyTask);
      }
      
      // Execute plan with progress tracking
      const results: any[] = [];
      let completedTasks = 0;
      
      await this.planner!.executePlan(plan, (task: any) => {
        if (task.status === 'completed') {
          completedTasks++;
          results.push({
            taskId: task.id,
            description: task.description,
            result: task.result
          });
        }
        
        // Report progress
        const progress = (completedTasks / plan.tasks.length) * 100;
        options.onProgress?.(task.id, task.status, progress);
        
        // Track performance
        if (this.performanceOptimizer && options.trackPerformance !== false) {
          const duration = Date.now() - startTime;
          this.performanceOptimizer.recordMetric(
            `plan_execution_${task.tool}`,
            duration,
            task.status === 'completed',
            task.error,
            { objective, taskType: task.tool, priority: options.priority }
          );
        }
      });
      
      const totalDuration = Date.now() - startTime;
      
      // Get analytics and suggestions
      const analytics = this.performanceOptimizer?.getSessionAnalytics() || {};
      const suggestions = this.performanceOptimizer?.getOptimizationSuggestions() || [];
      
      // Store execution results in context
      if (this.contextManager) {
        await this.contextManager.addContext(
          `execution_${plan.id}`,
          { 
            objective, 
            plan, 
            results, 
            duration: totalDuration,
            success: true
          },
          { 
            type: 'execution', 
            tags: ['completed', 'plan', objective.split(' ')[0]],
            priority: 'medium'
          }
        );
      }
      
      logger.info(`‚úÖ Enhanced plan completed in ${totalDuration}ms`);
      
      return {
        success: true,
        results,
        analytics,
        suggestions
      };
      
    } catch (error) {
      const totalDuration = Date.now() - startTime;
      
      // Track failed execution
      if (this.performanceOptimizer) {
        this.performanceOptimizer.recordMetric(
          'plan_execution_failed',
          totalDuration,
          false,
          error instanceof Error ? error.message : 'Unknown error',
          { objective, priority: options.priority }
        );
      }
      
      logger.error(`‚ùå Enhanced plan execution failed:`, error);
      
      return {
        success: false,
        results: [],
        analytics: this.performanceOptimizer?.getSessionAnalytics() || {},
        suggestions: []
      };
    }
  }

  /**
   * Perform intelligent web search using Exa
   */
  async intelligentWebSearch(
    query: string,
    context: 'development' | 'research' | 'troubleshooting' | 'learning' = 'development',
    options: {
      includeCode?: boolean;
      language?: string;
      maxResults?: number;
    } = {}
  ): Promise<any> {
    if (!this.exaSearchTool) {
      throw new Error('Exa Search tool not available');
    }
    
    const startTime = Date.now();
    
    try {
      let result;
      
      if (options.includeCode && options.language) {
        result = await this.exaSearchTool.searchCode(query, options.language, {
          includeGitHub: true,
          includeStackOverflow: true,
          includeDocumentation: true
        });
      } else {
        result = await this.exaSearchTool.smartSearch(query, context);
      }
      
      // Track performance
      if (this.performanceOptimizer) {
        this.performanceOptimizer.recordMetric(
          'exa_search',
          Date.now() - startTime,
          true,
          undefined,
          { query, context, resultCount: result.results.length }
        );
      }
      
      // Store in context
      if (this.contextManager) {
        await this.contextManager.addContext(
          `search_${Date.now()}`,
          { query, results: result.results.slice(0, 5) }, // Store top 5 results
          { type: 'temporary', tags: ['search', context], priority: 'low' }
        );
      }
      
      return result;
      
    } catch (error) {
      if (this.performanceOptimizer) {
        this.performanceOptimizer.recordMetric(
          'exa_search',
          Date.now() - startTime,
          false,
          error instanceof Error ? error.message : 'Unknown error'
        );
      }
      
      throw error;
    }
  }

  /**
   * Find optimal AI models for a task using Hugging Face
   */
  async findOptimalModels(
    taskDescription: string,
    constraints: {
      maxSize?: string;
      commercial?: boolean;
      language?: string;
      performance?: 'speed' | 'quality' | 'balanced';
    } = {}
  ): Promise<any> {
    if (!this.huggingFaceTool) {
      throw new Error('Hugging Face tool not available');
    }
    
    const startTime = Date.now();
    
    try {
      const result = await this.huggingFaceTool.getModelRecommendations(taskDescription, {
        maxSize: constraints.maxSize,
        requiresCommercialLicense: constraints.commercial,
        performanceRequirement: constraints.performance || 'balanced'
      });
      
      // Track performance
      if (this.performanceOptimizer) {
        this.performanceOptimizer.recordMetric(
          'huggingface_search',
          Date.now() - startTime,
          true,
          undefined,
          { taskDescription, constraints, resultCount: result.recommended.length }
        );
      }
      
      // Store recommendations in context
      if (this.contextManager) {
        await this.contextManager.addContext(
          `model_recommendations_${Date.now()}`,
          { task: taskDescription, recommendations: result },
          { type: 'temporary', tags: ['models', 'ai', 'recommendations'], priority: 'medium' }
        );
      }
      
      return result;
      
    } catch (error) {
      if (this.performanceOptimizer) {
        this.performanceOptimizer.recordMetric(
          'huggingface_search',
          Date.now() - startTime,
          false,
          error instanceof Error ? error.message : 'Unknown error'
        );
      }
      
      throw error;
    }
  }

  /**
   * Get context-aware suggestions for the current session
   */
  async getContextualSuggestions(currentObjective?: string): Promise<{
    contextSuggestions: string[];
    optimizationSuggestions: any[];
    relatedPatterns: any[];
    recommendedActions: string[];
  }> {
    const suggestions = {
      contextSuggestions: [] as string[],
      optimizationSuggestions: [] as any[],
      relatedPatterns: [] as any[],
      recommendedActions: [] as string[]
    };
    
    // Get context-based suggestions
    if (this.contextManager && currentObjective) {
      const dummyTask = {
        id: 'suggestion_lookup',
        description: currentObjective,
        tool: 'context',
        args: {},
        dependencies: [],
        status: 'pending' as const,
        priority: 'medium' as const,
        retryCount: 0,
        maxRetries: 3
      };
      
      const contextResults = await this.contextManager.getContextForTask(dummyTask);
      suggestions.contextSuggestions = contextResults.suggestions;
    }
    
    // Get performance optimization suggestions
    if (this.performanceOptimizer) {
      suggestions.optimizationSuggestions = this.performanceOptimizer.getOptimizationSuggestions();
      suggestions.relatedPatterns = this.performanceOptimizer.getPatterns().slice(0, 5);
    }
    
    // Generate recommended actions based on context and performance data
    suggestions.recommendedActions = this.generateRecommendedActions(
      suggestions.contextSuggestions,
      suggestions.optimizationSuggestions
    );
    
    return suggestions;
  }

  /**
   * Get comprehensive system status
   */
  async getSystemStatus(): Promise<SystemStatus> {
    const status: SystemStatus = {
      planning: {
        isReady: !!this.planner,
        activePlans: 0,
        completedTasks: 0,
        failedTasks: 0
      },
      context: {
        isReady: !!this.contextManager,
        totalItems: 0,
        memoryUsage: 0,
        sessionId: ''
      },
      analytics: {
        isReady: !!this.performanceOptimizer,
        totalMetrics: 0,
        learnedPatterns: 0,
        suggestions: 0
      },
      tools: {
        available: [],
        connected: [],
        failed: []
      }
    };
    
    // Planning status
    if (this.planner) {
      const context = this.planner.getExecutionContext();
      status.planning.completedTasks = context.history.filter((h: any) => h.success).length;
      status.planning.failedTasks = context.history.filter((h: any) => !h.success).length;
    }
    
    // Context status
    if (this.contextManager) {
      const summary = this.contextManager.getContextSummary();
      status.context.totalItems = summary.totalItems;
      status.context.memoryUsage = summary.totalSize;
      status.context.sessionId = this.contextManager.getCurrentSessionId();
    }
    
    // Analytics status
    if (this.performanceOptimizer) {
      const metrics = this.performanceOptimizer.getMetrics();
      const patterns = this.performanceOptimizer.getPatterns();
      const suggestions = this.performanceOptimizer.getOptimizationSuggestions();
      
      status.analytics.totalMetrics = metrics.length;
      status.analytics.learnedPatterns = patterns.length;
      status.analytics.suggestions = suggestions.length;
    }
    
    // Tools status
    const availableTools = ['filesystem', 'git', 'terminal', 'smithery'];
    if (this.exaSearchTool) availableTools.push('exa-search');
    if (this.huggingFaceTool) availableTools.push('hugging-face');
    
    status.tools.available = availableTools;
    
    // Test tool connectivity
    const connectedTools = [];
    const failedTools = [];
    
    if (this.exaSearchTool) {
      try {
        const isConnected = await this.exaSearchTool.testConnection();
        if (isConnected) {
          connectedTools.push('exa-search');
        } else {
          failedTools.push('exa-search');
        }
      } catch {
        failedTools.push('exa-search');
      }
    }
    
    if (this.huggingFaceTool) {
      try {
        const isConnected = await this.huggingFaceTool.testConnection();
        if (isConnected) {
          connectedTools.push('hugging-face');
        } else {
          failedTools.push('hugging-face');
        }
      } catch {
        failedTools.push('hugging-face');
      }
    }
    
    status.tools.connected = connectedTools;
    status.tools.failed = failedTools;
    
    return status;
  }

  /**
   * Save all system state to persistent storage
   */
  async saveSystemState(): Promise<void> {
    const promises = [];
    
    if (this.contextManager) {
      promises.push(this.contextManager.saveContext());
    }
    
    if (this.performanceOptimizer) {
      promises.push(this.performanceOptimizer.saveAnalytics());
    }
    
    await Promise.allSettled(promises);
    logger.info('üíæ System state saved');
  }

  /**
   * Private initialization methods
   */
  private async initializePerformanceOptimizer(): Promise<void> {
    try {
      this.performanceOptimizer = new PerformanceOptimizer(this.config.analytics.persistencePath);
      this.performanceOptimizer.setLearningEnabled(this.config.analytics.learningEnabled);
      
      logger.info('üìä Performance optimizer initialized');
    } catch (error) {
      logger.error('Failed to initialize performance optimizer:', error);
      throw error;
    }
  }

  private async initializeContextManager(): Promise<void> {
    try {
      this.contextManager = new EnhancedContextManager(
        this.config.context.maxSize,
        this.config.context.persistencePath
      );
      
      if (this.config.context.crossSessionRetention) {
        await this.contextManager.loadPreviousSessionContext();
      }
      
      logger.info('üß† Enhanced context manager initialized');
    } catch (error) {
      logger.error('Failed to initialize context manager:', error);
      throw error;
    }
  }

  private async initializeEnhancedPlanner(): Promise<void> {
    try {
      if (!this.contextManager) {
        throw new Error('Context manager must be initialized before planner');
      }
      
      this.planner = new EnhancedAgenticPlanner(
        this.modelClient,
        this.mcpManager,
        this.voiceSystem
      );
      
      logger.info('üéØ Enhanced agentic planner initialized');
    } catch (error) {
      logger.error('Failed to initialize enhanced planner:', error);
      throw error;
    }
  }

  private async initializeAdditionalTools(): Promise<void> {
    // Initialize Exa Search tool
    if (this.config.tools.exaSearch.enabled) {
      try {
        this.exaSearchTool = new ExaSearchTool({
          enabled: true,
          apiKey: this.config.tools.exaSearch.apiKey,
          baseUrl: 'https://api.exa.ai',
          timeout: 30000,
          maxResults: 20
        });
        
        logger.info('üîç Exa Search tool initialized');
      } catch (error) {
        logger.warn('Failed to initialize Exa Search tool:', error);
      }
    }
    
    // Initialize Hugging Face tool
    if (this.config.tools.huggingFace.enabled) {
      try {
        this.huggingFaceTool = new HuggingFaceTool({
          enabled: true,
          apiKey: this.config.tools.huggingFace.apiKey,
          baseUrl: 'https://huggingface.co/api',
          timeout: 30000
        });
        
        logger.info('ü§ó Hugging Face tool initialized');
      } catch (error) {
        logger.warn('Failed to initialize Hugging Face tool:', error);
      }
    }
  }

  private loadEnhancedConfig(appConfig: AppConfig): EnhancedSystemConfig {
    // Extract enhanced configuration from app config or use defaults
    return {
      planning: {
        enabled: appConfig.features?.enhancedPlanning ?? true,
        maxConcurrentTasks: 5,
        autoRecovery: true,
        contextAware: true
      },
      context: {
        enabled: appConfig.features?.contextManagement ?? true,
        maxSize: 50 * 1024 * 1024, // 50MB
        persistencePath: '.codecrucible/context',
        crossSessionRetention: true
      },
      analytics: {
        enabled: appConfig.features?.analytics ?? true,
        learningEnabled: true,
        persistencePath: '.codecrucible/analytics',
        optimizationThreshold: 0.8
      },
      tools: {
        exaSearch: {
          enabled: appConfig.mcp?.servers?.exa?.enabled ?? false,
          apiKey: appConfig.mcp?.servers?.exa?.apiKey
        },
        huggingFace: {
          enabled: appConfig.mcp?.servers?.huggingface?.enabled ?? false,
          apiKey: appConfig.mcp?.servers?.huggingface?.apiKey
        }
      }
    };
  }

  private generateRecommendedActions(
    contextSuggestions: string[],
    optimizationSuggestions: any[]
  ): string[] {
    const actions: string[] = [];
    
    // High-priority optimization actions
    const criticalSuggestions = optimizationSuggestions.filter(s => s.priority === 'critical');
    if (criticalSuggestions.length > 0) {
      actions.push(`Address ${criticalSuggestions.length} critical performance issues`);
    }
    
    // Context-based actions
    if (contextSuggestions.length > 0) {
      actions.push(`Review ${contextSuggestions.length} contextual suggestions`);
    }
    
    // Learning opportunities
    const highConfidencePatterns = this.performanceOptimizer?.getPatterns().filter((p: any) => p.confidence > 0.8) || [];
    if (highConfidencePatterns.length > 3) {
      actions.push('Leverage learned patterns for improved performance');
    }
    
    // General recommendations
    if (actions.length === 0) {
      actions.push('Continue with current workflow - system is performing well');
    }
    
    return actions;
  }

  /**
   * Cleanup and shutdown
   */
  async shutdown(): Promise<void> {
    logger.info('üõë Shutting down enhanced system...');
    
    try {
      // Save all state before shutdown
      await this.saveSystemState();
      
      // Reset initialization flag
      this.isInitialized = false;
      this.initializationPromise = undefined;
      
      logger.info('‚úÖ Enhanced system shutdown complete');
    } catch (error) {
      logger.error('Error during enhanced system shutdown:', error);
    }
  }
}
